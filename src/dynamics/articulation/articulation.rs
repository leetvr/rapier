#![allow(missing_docs)] // For downcast.

use downcast_rs::{impl_downcast, DowncastSync};
use na::DVectorSliceMut;

use crate::dynamics::{IntegrationParameters, RigidBodyVelocity};
use crate::math::{Isometry, JacobianSliceMut, Real, Vector};

/// Trait implemented by all articulations following the reduced-coordinate formation.
pub trait Articulation: DowncastSync {
    /// The number of degrees of freedom allowed by the articulation.
    fn ndofs(&self) -> usize;
    /// The position of the multibody link containing this articulation relative to its parent.
    fn body_to_parent(
        &self,
        parent_shift: &Vector<Real>,
        body_shift: &Vector<Real>,
    ) -> Isometry<Real>;
    /// Update the jacobians of this articulation.
    fn update_jacobians(&mut self, body_shift: &Vector<Real>, vels: &[Real]);
    /// Integrate the position of this articulation.
    fn integrate(&mut self, parameters: &IntegrationParameters, vels: &[Real]);
    /// Apply a displacement to the articulation.
    fn apply_displacement(&mut self, disp: &[Real]);

    /// Sets in `out` the non-zero entries of the articulation jacobian transformed by `transform`.
    fn jacobian(&self, transform: &Isometry<Real>, out: &mut JacobianSliceMut<Real>);
    /// Sets in `out` the non-zero entries of the time-derivative of the articulation jacobian transformed by `transform`.
    fn jacobian_dot(&self, transform: &Isometry<Real>, out: &mut JacobianSliceMut<Real>);
    /// Sets in `out` the non-zero entries of the velocity-derivative of the time-derivative of the articulation jacobian transformed by `transform`.
    fn jacobian_dot_veldiff_mul_coordinates(
        &self,
        transform: &Isometry<Real>,
        vels: &[Real],
        out: &mut JacobianSliceMut<Real>,
    );

    /// Multiply the articulation jacobian by generalized velocities to obtain the
    /// relative velocity of the multibody link containing this articulation.
    fn jacobian_mul_coordinates(&self, vels: &[Real]) -> RigidBodyVelocity;
    /// Multiply the articulation jacobian by generalized accelerations to obtain the
    /// relative acceleration of the multibody link containing this articulation.
    fn jacobian_dot_mul_coordinates(&self, vels: &[Real]) -> RigidBodyVelocity;

    /// Fill `out` with the non-zero entries of a damping that can be applied by default to ensure a good stability of the articulation.
    fn default_damping(&self, out: &mut DVectorSliceMut<Real>);

    /// The maximum number of impulses needed by this articulations for
    /// its constraints.
    fn nimpulses(&self) -> usize {
        // TODO: keep this?
        self.ndofs() * 3
    }

    /*
    /// Maximum number of velocity constrains that can be generated by this articulation.
    fn num_velocity_constraints(&self) -> usize {
        0
    }

    /// Initialize and generate velocity constraints to enforce, e.g., articulation limits and motors.
    fn velocity_constraints(
        &self,
        _params: &IntegrationParameters,
        _multibody: &Multibody<Real>,
        _link: &MultibodyLink<Real>,
        _assembly_id: usize,
        _dof_id: usize,
        _ext_vels: &[Real],
        _ground_j_id: &mut usize,
        _jacobians: &mut [Real],
        _velocity_constraints: &mut ConstraintSet<Real, (), (), usize>,
    ) {
    }

    /// The maximum number of non-linear position constraints that can be generated by this articulation.
    fn num_position_constraints(&self) -> usize {
        0
    }

    /// Initialize and generate the i-th position constraints to enforce, e.g., articulation limits.
    fn position_constraint(
        &self,
        _i: usize,
        _multibody: &Multibody<Real>,
        _link: &MultibodyLink<Real>,
        _handle: BodyPartHandle<()>,
        _dof_id: usize,
        _jacobians: &mut [Real],
    ) -> Option<GenericNonlinearConstraint<Real, ()>> {
        None
    }
     */

    fn clone(&self) -> Box<dyn Articulation>;
}

impl_downcast!(Articulation);
